{"posts":[{"title":"Java进程间共享锁","text":"背景业务系统运行时产生了大量的小文件（大小在10kb左右，包含一些表单的内容，rest接口的访问记录），考虑到将这些内容存储在数据库中对数据库压力较大，因此转为文件存储，但由于restful接口访问频繁，导致产生了大量的小文件，最终导致服务器inode占用率过高，触发告警 原因 什么是inode?inode包含文件的元信息，具体来说有以下内容： * 文件的字节数 * 文件拥有者的User ID * 文件的Group ID * 文件的读、写、执行权限 * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 * 链接数，即有多少文件名指向这个inode * 文件数据block的位置 大量小文件的产生导致服务器inode占用过高，触发告警，如果inode继续增加可能会导致无法创建文件。 解决思路 将多个小文件合并为一个大文件处理，思路有很多： 可以合并为一个大的文本文件，每次记录内容的偏移量，读的时候根据起始位置和偏移量来获取内容。 仍保持单个文件的独立性，将多个文件合并为一个大的压缩文件。 经过尝试发现，方案1可能会导致读写错误，具体表现为文本不但会增加也可能会删除，删除后要更新所有文件的起始值和偏移值，这反而加重了数据库的负担，而且偏移量一旦计算错误将会导致所有的文件内容读到的结果都是错误的。 方案二保持了文件的独立性，只需记录文件路径即可，即便某个文件路径错误也不影响其他文件的读取，同理，删除也不会影响其他的文件读取，唯一要解决的便是并发环境即分布式环境的问题（同时读写文件），经测试和运行满足生产环境需求，且由于是一个压缩文件，inode占用率不会飙升，因此采用了方案二，并已生产部署。 在此不详细讨论如何生成并读写压缩文件（将产生的多个文件放入压缩包中即可），着重说明如何保证同一时刻一个压缩文件不能被同时写入。 详细实现 Java 提供了文件锁FileLock类，利用这个类可以控制不同程序(JVM)对同一文件的并发访问，实现进程间文件同步操作。FileLock是java 1.4 版本后出现的一个类，它可以通过对一个可写文件(w)加锁，保证同时只有一个进程可以拿到文件的锁，这个进程从而可以对文件做访问；而其它拿不到锁的进程要么选择被挂起等待，要么选择去做一些其它的事情， 这样的机制保证了众进程可以顺序访问该文件。也可以看出，能够利用文件锁的这种性质，在一些场景下，虽然我们不需要操作某个文件， 但也可以通过 FileLock 来进行并发控制，保证进程的顺序执行，避免数据错误。 1.保证获取到的文件对象唯一，每次写入动作时取到的文件是同一个 private static synchronized File getInstance(String path) throws ZipException { if (map.containsKey(path)) { return map.get(path); } else { CompressedFile compressedFile = new CompressedFile(path); zipMap.put(path, compressedFile); return compressedFile; } } 2.使用FileLock锁确保同一时刻只有一个进程可以写文件,使用try with resource自动关闭文件流 public static String writeZipContent(String filePath, String subPath, InputStream fis) throws Exception { File zipFile = getInstance(filePath); synchronized (zipFile) { File f = new File(filePath); if (!f.getParentFile().exists()) { f.getParentFile().mkdirs(); } try (RandomAccessFile randomAccessFile = new RandomAccessFile(new File(zipFilePath + &quot;.lock&quot;), &quot;rws&quot;); FileChannel channel = randomAccessFile.getChannel()) { FileLock fileLock; do { fileLock = channel.lock(); } while (fileLock == null || !fileLock.isValid()); //do something return &quot;path&quot;; } catch (Exception ex) { logger.error(ex.getMessage(), ex); throw ex; } } } 补充说明在java.io.RandomAccessFile类的open方法，提供了参数实现独占的方式打开文件： RandomAccessFile raf = new RandomAccessFile(file, &quot;rws&quot;); 其中的“rws”参数，rw代表读取和写入，s代表了同步方式，也就是同步锁。 ​​","link":"/posts/2202924434/"},{"title":"System.currentTimeMillis性能问题测试与处理","text":"背景新项目打算做前后端分离，需要关注接口的响应时间，以便在出现问题时定位到是哪个接口，记得偶然看到获取多线程并发环境下该方法对性能可能会有影响，因此在项目前期做一个小测试。 过程 System.currentTimeMillis()在java中是最常用的获取系统时间的方法，它返回的是1970年1月1日0点到现在经过的毫秒数。 我们看以看到它在Java中的实现为：public static native long currentTimeMillis(); native关键字说明这个方法底层是由C语言实现的，我们稍后在讲，先做一个简单的测试。 这次测试电脑配置为 Intel(R) Core(TM) i7-8550 16内存。测试很简单10000次for循环调用和多线程10000次调用，直接看结果：单线程下10000次调用消耗时间为 6713300 ns多线程下10000次调用消耗时间为 4968593100 ns 可以看到相差还是比较大的,在串行情况下这个api其实性能很好，但是在并发情况下回急剧下降，原因在于计时器在所有进程之间共享，并且其还一直在发生变化，当大量线程尝试同时去访问计时器的时候，就涉及到资源的竞争，于是也就出现并行效率远低于串行效率的现象了。所以在高并发场景下要慎重使用System.nanoTime()和System.currentTimeMillis()这两个API。 在搜索过程中我找到的一篇大家都比较信服的文章来解释为什么会这样，连接如下:http://pzemtsov.github.io/2017/07/23/the-slow-currenttimemillis.html ​ 文章很长，讲的很详细，甚至从汇编语言的角度讲了为什么会这样，有几个比较重要的观点： 调用gettimeofday()需要从用户态切换到内核态； gettimeofday()的表现受Linux系统的计时器（时钟源）影响，在HPET计时器下性能尤其差； 系统只有一个全局时钟源，高并发或频繁访问会造成严重的争用 HPET计时器问题在处理器层面已经解决处理器系列以不同方式增加时间戳计数器： 对于奔腾M处理器（系列[06H]，型号[09H，0DH]）；对于奔腾4处理器，英特尔至强处理器（系列[0FH]，型号[00H，01H或02H]）；对于P6系列处理器：时间戳记计数器会随着每个内部处理器时钟周期的增加而增加。内部处理器时钟周期由当前内核时钟与总线时钟之比确定。英特尔®SpeedStep®技术过渡也可能会影响处理器时钟。 对于奔腾4处理器，英特尔至强处理器（系列[0FH]，型号[03H及更高版本]）；适用于Intel Core Solo和Intel Core Duo处理器（系列[06H]，型号[0EH]）；用于Intel Xeon处理器5100系列和Intel Core 2 Duo处理器（系列[06H]，型号[0FH]）；适用于Intel Core 2和Intel Xeon处理器（系列[06H]，DisplayModel [17H]）；对于Intel Atom处理器（系列[06H]，DisplayModel [1CH]）：时间戳记计数器以恒定速率递增。 解决思路 网上的解决方法有很多： 维护一个全局缓存，使用单线程调度器器按毫秒更新时间戳，用到了 ScheduledThreadPoolExecutor，代码如下 12345678910111213141516171819202122232425262728public class SystemClock { private static final SystemClock MILLIS_CLOCK = new SystemClock(1); private final long precision; private final AtomicLong now; private SystemClock(long precision) { this.precision = precision; now = new AtomicLong(System.currentTimeMillis()); scheduleClockUpdating(); } public static SystemClock millisClock() { return MILLIS_CLOCK; } private void scheduleClockUpdating() { ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(runnable -&gt; { Thread thread = new Thread(runnable, &quot;system.clock&quot;); thread.setDaemon(true); return thread; }); scheduler.scheduleAtFixedRate(() -&gt; now.set(System.currentTimeMillis()), precision, precision, TimeUnit.MILLISECONDS); } public long now() { return now.get(); } ​​","link":"/posts/4201659447/"},{"title":"websoket构建站内通知","text":"背景传统的报表或者统计展示都是统计一段时间的数据，然后由网页发起接口调用进而展示数据，对于一些不需要实时展示的内容来说是可以，但对于一些需要即时看到并处理的信息则可能会延后。 原因 网页端定时获取数据可能会造成信息的滞后，对于一些需要立即处理的事件可能会延误。 解决思路 不再使用前端定时调用接口的形式获取数据，使用websocket来即时从后台推送数据到前端。 使用主流长连接框架netty实现websocket功能。 使用jJavaEE7支持的@ServerEndpoint注解实现websocket。 若使用netty实现，性能会较好，但需要新启端口用于netty的连接与端口监听（默认为8888），使用注解实现则可以共用web 8080端口，减轻了实施的工作量，企业用户也无需新开防火墙申请变更，因此使用@ServerEndpoint实现websocket达到实时发送信息的目的。（在之前的章节提到了如何使用netty来做心跳检测以及信息传递） 详细实现 1.在类上使用注解@ServerEndpoint，并指定编解码类，因为实际场景的数据不只是字符串那么简单，一般都是json对象。还需实现 onOpen onClose onError三个方法，用于处理打开，关闭，异常时的处理场景。 同时onMessage方法用户处理客户端向服务端发送信息时的处理逻辑。 import net.sf.json.JSONObject; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import javax.websocket.*; import javax.websocket.server.ServerEndpoint; @ServerEndpoint(value = &quot;/websocket&quot;, encoders = {MessageEncoder.class }) public class SystemRemindSocketServer { private Logger logger = LoggerFactory.getLogger(SystemRemindSocketServer.class); @OnMessage public void onMessage(String message, Session session) throws IOException, InterruptedException, EncodeException { //暂时无需处理网页端发送的信息 //test // for(int i = 0;i&lt;5;i++){ // JSONObject data = new JSONObject(); // data.put(&quot;icon&quot;,&quot;ts-component&quot;); // data.put(&quot;taskId&quot;,1386); // data.put(&quot;time&quot;,&quot;2019-03-26 14:31:30&quot;); // data.put(&quot;title&quot;,&quot;当时明月在,曾照彩云归.&quot;); // data.put(&quot;link&quot;,&quot;/&quot;); // data.put(&quot;template&quot;,&quot;balantflow.systemremind.message.flow&quot;); // session.getBasicRemote().sendText(data.toString()); // } } @OnOpen public void onOpen(Session session) { String userId = session.getUserPrincipal().getName(); String sessionId = session.getId(); SystemRemindMessageManager.sessionMap.put(userId, session); } @OnClose public void onClose(Session session) { String userId = session.getUserPrincipal().getName(); SystemRemindMessageManager.sessionMap.remove(userId); } @OnError public void onError(Throwable t) { logger.error(&quot;web socket error ,&quot; + t.getMessage()); } } 2.编解码类的实现，直接用jsonobject格式化即可 public class MessageEncoder implements Encoder.Text&lt;SystemRemindMessageVo&gt; { @Override public void destroy() { } @Override public void init(EndpointConfig arg0) { } @Override public String encode(SystemRemindMessageVo messagepojo) throws EncodeException { try { return JSONObject.fromObject(messagepojo).toString(); } catch (Exception e) { return null; } } } 3.前端建立连接与数据处理 $(function(){ //启动时建立连接 var notifyws = new WebSocket(&quot;ws://localhost:8080/balantflow/websocket&quot;); notifyws.onopen = function(evt) { //console.log(evt); }; //后台发送消息时的处理逻辑 notifyws.onmessage = function(evt) { var newnotify = []; newnotify.push(JSON.parse(evt.data)); updateInstant(newnotify); }; //断开后重新连接 notifyws.onclose = function(evt) { notifyws = new WebSocket(&quot;ws://localhost:8080/balantflow/websocket&quot;); }; }) 补充说明部署环境时要注意修改websocket配置，因为在用户机器上连接localhost:8080是没用的，要改为具体的websocket地址 ​​","link":"/posts/549604128/"},{"title":"为什么中国的 996 干不过美国的 955","text":"看到了老板发的文章，特别有感触，中国的SaaS个性化需求太多，付费意愿低下也是影响 2B 企业战略的很大因素。导致很多企业服务厂商要给客户做大量定制。这个问题的原因是中国企业管理不规范，老板文化太重。 原文: 为什么中国的 996 干不过美国的 955 大概从 2019 年上半年开始，有一个问题一直困扰着我，在 2B 领域，为啥中国的公司如此努力的加班，但是在产品上还是不能跟国外的比？虽然我们公司不是加班很多，但是相比国外同类公司还是工作时长要长很多，我们最近为了赶持续部署产品上线，相关团队基本上是 997。腾讯云，阿里云，我了解到的情况也是加班比较多的，996 的情况不在少数。但是你看中美两国云服务的产品，显然国外的还是要比国内好一大截。把这个问题放大一点，在中美两国贸易战的背景下，“为什么中国的 996 干不过美国的 955？”。我们从三个方面来看这个问题。一、中国 IT 从业者的素质到底行不行？ 对比中国的一线城市，我觉得从业者的专业水平并不差。我十年前在硅谷工作，大量的印度大妈的 Title 都是 Principal Engineer，这大概也是我当初决定回国的原因之一。近几年，有大量工程师在中国工作一段时间后去美国的，以及在美国工作一段时间后回国的。我感觉在从业者素质方面，高端人才两边是差不多的。但是中国实在是人多，论数量，初级从业者肯定更多，所以在日常感觉上，国内的整体素质没有国外高，我认为在我们讨论的业务范围，这是一种错觉。 但是国内从业者在专业度确实是欠缺的。这点从简历就能看出来。中国即使有些很高级的工程师，看简历也是写的不合格的，从内容到格式都不合格。但是你去国外招聘，无论水平多烂，简历都是写的非常漂亮。国外在如何写简历这件事情上的培训是相当成熟的，值得我们学习。 另外在理解自己与公司的关系上，国内普遍带有更多情感，而国外更理性。这一点要展开就太大了，要从文化开始讲。但是无论如何，我认为这个差异只影响管理方式，不应该在产出质量上有大的影响。 二、中国的 IT 从业者是不是不够努力？ 这个问题是显而易见的，但我还是想说一下。每次晚上 10 点左右，在公司楼下打车，滴滴告诉你排队 101 号，一线城市都这样，深圳科技园只是一个缩影。我们说 996，只是一个代名词，有可能是 10-10-6，但起码我从来没有见过民营 IT 企业是 955 的。除此以外，国内大量公司在非工作时间是要处理公事的，也就是公私没有那么分明。以至于企业微信每周都会给你一个报告，告诉你这一周最晚处理公事对话是几点。在朋友圈晒凌晨两三点的不在少数吧？ 即使是这样，相比其他行业，IT 行业可能都是工作时间最短的。建筑行业，工厂制造业，基本上一年就休一个春节。中国这么多人，每个人每天都有 24 小时，中国这些年的 GDP 增长，就是这么靠堆时间堆出来的。但是堆时间的杠杆率越来越低了，所以 GDP 的增速下降很快。 三、中国 2B 公司的战略行不行？ 产品做不好，如果不是人的问题，不是投入度问题，那大概只剩下方向问题了。我们先来看一组截图： 对比国内外几个云厂商的首页，其实问题还挺明显的。首页就是门面，代表了你的形象，代表了你想传递什么信息给客户。美国的厂商基本上是在讲产品和技术，而中国云厂商基本上是在搞促销，而且“吃相很难看”。我一直认为作为一个面向企业的专业服务商，参加双十一这样的活动就是一种耻辱。我从来没见那个美国的企业服务公司参加黑五。你看阿里云的首页在视觉观感上是不是越来越像淘宝？相由心生啊！这么搞如何塑造专业形象呢？没有专业形象，附加值就上不去，所以生意越做越苦逼。“IBM，Oracle，微软，Google，AWS，阿里云，腾讯云，华为云”这几个 LOGO 大家看到时候我相信内心的感觉是不一样的。我觉得这就是差距。 阿里这种强运营的做法，确实能获得更多客户，其他厂商也不得不跟进，就导致了现在局面：中国特色运营驱动的云计算产业。业务如果靠销售驱动，杠杆率最低，运营其次，产品最高。所以你去看销售驱动的公司，往往有很多人，但是人均产值很低，比如地产，软件外包。但是产品驱动的公司/业务，往往有超高人均产值，比如微信。再比如国外的 Atlassian（典型产品 JIRA），目前市值 276 亿美元，员工 3600 人，人均市值 920 万美元。这家公司没有销售。 我们在做绩效考核的时候有一句话：你考核什么你就会得到什么。再放大一点，“这个社会奖励什么，就会得到什么”。我想来想去，觉得这里的核心不是供给的问题，而是需求的问题。国内目前的 IT 大环境实质上是鼓励 60 分产品，不重视 80 分或者 100 分产品。花一份精力，可以把产品做到 60 分；花两份精力可以把产品做到 80 分；但是花 10 份精力才能做到 100 分。如果没有足够的正向激励，没有人会去做 100 分产品。所以中国市场上有很多 60 分产品，鲜有 80 分产品，没有 100 分产品。做过企业级项目打单，招投标的人想来都明白，能不能拿下客户，产品最多只有一半的因素。而且很多企业目前追求的是能用，并没有那么强烈的品质诉求。 这个问题说到底也不是 IT 行业的问题。我觉得更明显的是在建筑行业。中国 30 年时间盖了比别人 200 年还要多的房子，可以想象这个房屋质量。每次去老牌资本主义国家，看到人家的写字楼，虽然已经上百年，但那种品质感，国内少有。全球云计算领头羊 AWS 成立于 2006 年，刚才说的 Atlassian 成立于 2002 年。产品驱动就是前面的投入很大，时间很长。我们追赶追求短平快，品质也难以做好。 除此以外，个性化需求太多，付费意愿低下也是影响 2B 企业战略的很大因素。中国企业的个性化诉求太多了，导致很多企业服务厂商要给客户做大量定制。这个问题的原因是中国企业管理不规范，老板文化太重。但我相信这个问题正在改善，包括企业微信/钉钉在内的各种工具在倒逼中小企业的管理规范化，标准化。付费意愿也是，可以看到改善，但是依然很低。CODING 十个活跃用户里面，只有一个是付费的。如果产品你用了，仍然不付费，那企业只能想别的办法搞钱。 以上种种，导致了想要在国内这个环境慢慢打磨产品变得不可能，基本上会死在路上。所以只能逼良为娼，先污染，后治理。虽然中国企业可能投入的人更多，但是抛开工程师的素质不谈，同样多的人力做一个产品和同时做两个产品，差距还是很大的。中国的 996 干不过美国的 955 还是路径选择问题，两条路的杠杆率差距太大。 包括巨头云厂商在内的各个企业，我相信从老板开始，都很清楚做好产品是王道，但实践就是非常困难，把各大云厂商的收入构成扒开看一看就知道究竟有多少真正是产品带来的收入。既要速度，又要质量，还舍不得短期利益，真的可以兼得吗？最近在消费品领域出现了各种“升级”，国产高品质商品迅速崛起，这是新一代中产阶级的需求拉动的。我相信软件行业会出现类似的升级，“Made in China”形象的提升一定不仅仅在制造业。","link":"/posts/2512426148/"},{"title":"什么是好的设计","text":"好设计是能影响用户非理性，改变情绪最终影响他的行为。设计的高境界在于只影响不明说，用户不需要领会设计意图，但情绪已经被感染了，在情绪的作用下，按照设计者预定的轨迹，自然做出选择。","link":"/posts/822959802/"},{"title":"使用RateLimiter限制访问频率","text":"背景通过查看接口访问日志发现某个注册接口请求量突然暴涨，并引发连锁反应，导致整个系统变慢。系统已经对接口做了做了权限认证，包含token认证，时效认证，禁用启用等功能，但没有对访问频率做限制，除了需要优化处理逻辑外，也要加上对接口的访问频率限制，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制。 原因及方案分析 常用的限流算法有两种：漏桶算法和令牌桶算法。 漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率。但是漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量. 解决思路 使用令牌桶算法限制接口访问频率sss。 详细实现 Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法来完成限流，非常易于使用。在项目中用了以下实现 1.频率是可以设置的，所以要存储初始值，频率发生改变时调用setRate方法即可，需要注意的是setRate的意义是每秒允许多少次访问，参数是一个double类型的值 RateLimiter rateLimit = RestComponentFactory.interfaceRateMap.getOrDefault(interfaceVo.getToken(), null); Double newRateLimit = interfaceVo.getQps(); if(interfaceVo.getQps()!= null &amp;&amp; interfaceVo.getQps() &gt; 0){ if(rateLimit == null){ rateLimit = RateLimiter.create(interfaceVo.getQps()); RestComponentFactory.interfaceRateMap.put(interfaceVo.getToken(), rateLimit); }else{ if(rateLimit.getRate() != newRateLimit){ rateLimit.setRate(newRateLimit); } } boolean rateFlag = rateLimit.tryAcquire(); if(!rateFlag){ throw new Exception470(); } } 补充说明RateLimiter类位于 com.google.common.util.concurrent.RateLimiter &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; ​​","link":"/posts/1900677851/"},{"title":"如何看待MVP-最小可行性产品","text":"关于产品MVP,我觉得值得讨论的是当我们把产品给用户体验的时候应该是一个完整可能的版本还是部分可用的产品，“简单”好，“不完整”不好。客户应该真正希望按原样使用该产品。不是因为它是复杂事物的 0.1 版，而是因为它是简单事物的 1.0 版。近来看到一篇文章是一名连续创业者Jason写的，我觉得挺有意思的，站在用户角度考虑了MVP的缺点 原文链接: I hate MVPs. So do your customers. Make it SLC instead. 原文: Product teams have been repeating the MVP (Minimum Viable Product) mantra for a decade now, without re-evaluating whether it’s the right way to maximize learning while pleasing the customer. Well, it’s not the best system. It’s selfish and it hurts customers. We don’t build MVPs at WP Engine. The motivation behind the MVP is still valid: Build something small, because small things are predictable and inexpensive to test.Get it into the market quickly, because real learning occurs only when real customers are using a real product.Trash it if it’s a flop, or invest if it’s a seedling with potential.MVPs are great for startups and product teams because they maximize validated learning about customers as quickly as possible. But it’s a selfish act. The problem is that customers hate MVPs. Startups are encouraged by the great Reid Hoffman to “launch early enough that you’re embarrassed by your v1.0 release.” But no customer wants to use an unfinished product that the creators are embarrassed by. Customers want great products they can use now. MVPs are too M and almost never V. Customers see that, and hate it. It might be great for the product team, but it’s bad for customers. And ultimately, what’s bad for customers is bad for the company. Fortunately, there’s a better way to build and validate new products. The insight comes by honoring the useful attributes of MVPs, which are listed above, while also giving just as much consideration to the customer’s experience. In order for the product to be small and delivered quickly, it has to be simple. Customers accept simple products every day. Even if it doesn’t do everything needed, as long as the product never claimed to do more than it does, customers are forgiving. For example, it was okay that early versions Google Docs had only 3% of the features of Microsoft Word, because Docs did a great job at what it was primarily designed for, which is simplicity and real-time collaboration. Docs was simple, but also complete. This is decidedly different from the classic MVP, which by definition isn’t complete (and in fact is embarrassing). “Simple” is good, “incomplete” is not. The customer should have a genuine desire to use the product, as-is. Not because it’s version 0.1 of something complex, but because it’s version 1.0 of something simple. It is not contradictory for products to be simple as well as complete. Examples include the first versions of WhatsApp, Snapchat, Stripe, Twilio, Twitter, and Slack. Some of those later expanded to add complexity (Snapchat, Stripe, Slack), whereas some kept it simple as a permanent value (Twitter, WhatsApp). Virgin Air started with just a single route — small, but complete. The final ingredient is that the product has to be lovable. People have to want to use it. Products that do less but are loved, are more successful than products which have more features, but that people dislike. The original, very-low-feature, very-highly-loved, hyper-successful early versions of all the products listed in the previous paragraph are examples. The Darwinian success loop of a product is a function of love, not of features. There are many ways to generate love. “Minimum” and “viable” are definitely not two of those ways. The current-in-vogue way is through design: Elegant UX combined with delightful UI. But there are other ways. The attitude and culture of the company itself can generate love, such as Buffer’s blog with its surprising transparency or MeetEdgar’s blog genuinely helping entrepreneurs or HubSpot’s blog which early on was at least as instrumental to their customers’ success as the actual product. Another way is through a deep connection to the psyche and work-style of customers, like Heroku who broke with marketing tradition by filling the homepage with command-line feature examples instead of benefit-statements, thereby connecting instantly with their geeky target customer: These are the components of the correct alternative to the MVP: Simple, Lovable and Complete (SLC). At WP Engine we pronounce it “Slick.” As in: “What’s the ‘Slick’ version of your idea?” Besides the above, there’s another benefit to SLC when you consider what happens with the next version of the product. A SLC product does not require ongoing development in order to add value. It’s possible that v1 should evolve for years into a v4, but you also have the option of not investing further in the product, yet it still adds value. An MVP that never gets additional investment is just a bad product. An SLC that never gets additional investment is a good, if modest product. Although not called SLC, there’s a popular meme in product circles that neatly encapsulates the idea of SLC in a diagram: The Modes of Transportation example from the Spotify product team: A skateboard is a SLC product. It’s faster than walking, it’s simple, many people love it, and it’s a complete product that doesn’t need additions to be fun or practical. At the same time, you can evolve the skateboard by adding a stem and handlebars, to create a scooter — only slightly less simple, and definitely loveable and complete. Next, you could grow the wheels, add a seat and some gears, and you have a bike. Again, less simple but now you have a product with massive benefits of speed, distance, and energy-efficiency. Complete, but many accessories available if you choose. Zooming into one of our examples above, Snapchat took an SLC progression similar to the transportation metaphor. The first iteration of the product was a screen where tapping anywhere took a picture that you could then send to someone else, at which time it disappeared. No video, no filters, no social networking, no commenting and no storage — simple, yet Lovable and Complete, as evidenced by its massive adoption. The insight of “no storage” was critical, but many people have theorized that the simplicity of the interface was also critical. The very fact that it was as simple as possible (while not sacrificing love-ability or completeness), caused its success. Later they added lots of stuff — video, filters, timelines, even video cameras inside sunglasses. It’s OK for products to become more complex. Starting out SLC does not preclude becoming complex later. With SLC, the outcomes are better and your options for next steps are better. If it fails, that’s OK, it’s a failed experiment. Both SLCs and MVPs will have that result because the whole point is to experiment. But if a SLC succeeds, you’ve already delivered business value and you have multiple futures available to you, none of which are urgent. You could build a v2.0, and because you’re already generating value, you have more time to decide what that should look like. You could even query existing customers to determine exactly what v2.0 should entail, instead of a set of alpha-testers who just want to know “when are you going to fix this?” Or, you can decide not to work on it. Not every product has to become complex. Not every product needs new major versions every two quarters. Some things can just remain simple, lovable, and complete. Ask your customers. They’ll agree.","link":"/posts/3177535693/"}],"tags":[{"name":"lock file","slug":"lock-file","link":"/tags/lock-file/"},{"name":"性能 时间戳","slug":"性能-时间戳","link":"/tags/%E6%80%A7%E8%83%BD-%E6%97%B6%E9%97%B4%E6%88%B3/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"saas 996","slug":"saas-996","link":"/tags/saas-996/"},{"name":"design view","slug":"design-view","link":"/tags/design-view/"},{"name":"qps ratelimiter","slug":"qps-ratelimiter","link":"/tags/qps-ratelimiter/"},{"name":"mvp 产品","slug":"mvp-产品","link":"/tags/mvp-%E4%BA%A7%E5%93%81/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"websocket","slug":"websocket","link":"/categories/websocket/"},{"name":"SaaS","slug":"SaaS","link":"/categories/SaaS/"},{"name":"design","slug":"design","link":"/categories/design/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：ElevenRadar 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}]}